diff -Naur before/src/metadata/taglib_handler.cc after/src/metadata/taglib_handler.cc
--- before/src/metadata/taglib_handler.cc	2010-03-25 14:58:10.000000000 +0000
+++ after/src/metadata/taglib_handler.cc	2013-01-25 21:25:26.000000000 +0000
@@ -41,6 +41,9 @@
 #include <tag.h>
 #include <id3v2tag.h>
 #include <mpegfile.h>
+#include <xiphcomment.h>
+#include <flacfile.h>
+#include <vorbisfile.h>
 #include <audioproperties.h>
 #include <attachedpictureframe.h>
 #include <textidentificationframe.h>
@@ -57,6 +60,179 @@
 
 using namespace zmm;
 
+namespace
+{
+    void fillAuxDataID3v2(Ref<CdsItem> item, TagLib::ID3v2::Tag* tag)
+    {
+          if (!tag)
+                  return;
+        
+          Ref<ConfigManager>      cm  = ConfigManager::getInstance();
+          Ref<Array<StringBase> > aux = cm->getStringArrayOption(CFG_IMPORT_LIBOPTS_ID3_AUXDATA_TAGS_LIST);
+        
+          if (aux == nil)
+                  return;
+        
+          const TagLib::ID3v2::FrameListMap& frames = tag->frameListMap();
+          TagLib::ID3v2::FrameListMap::ConstIterator framesEnd = frames.end();
+          //log_debug("Tag contains %i frame(s)\n", frames.size());
+          Ref<StringConverter> sc = StringConverter::i2i();
+        
+          for (int j = 0; j < aux->size(); j++)
+              {
+                      String desiredFrame = aux->get(j);
+                      if (!string_ok(desiredFrame))
+                              continue;
+                
+                      // UserTextFrames have the format: TXXX=...=... The first one is
+                      // the description, which we use to find the right frame
+                      if (desiredFrame.startsWith(String("TXXX")) && desiredFrame.length() > 5)
+                          {
+                                  String desiredDesc = desiredFrame.substring(5);
+                        
+                                  TagLib::ID3v2::UserTextIdentificationFrame *userFrame = TagLib::ID3v2::UserTextIdentificationFrame::find(tag, desiredDesc.c_str());
+                        
+                                  if (!userFrame)
+                                          continue;
+                        
+                                  TagLib::StringList l = userFrame->fieldList();
+                        
+                                  if(l.isEmpty())
+                                          continue;
+                    
+                                  // First element is description. Ignore it as we filtered based on it.
+                                  l.erase(l.begin());
+                                  TagLib::String allFields(l.toString(","));
+                                  String         value(allFields.toCString(true));
+                        
+                                  value = sc->convert(value);
+                                  //log_debug("Adding frame: %s with value %s\n", desiredFrame.c_str(), value.c_str());
+                                  item->setAuxData(desiredFrame, value);
+                              }
+                      // Standard frames. We just read the content as a string. That may
+                      // not be what we want for some of the concrete classes ...
+                      else //if(desiredFrame.startsWith(String("T")))
+                          {
+                                  TagLib::ID3v2::FrameListMap::ConstIterator it = frames.find(desiredFrame.c_str());
+                                  if (it == framesEnd)
+                                          continue;
+                        
+                                  const TagLib::List<TagLib::ID3v2::Frame*>& frames = it->second;
+                        
+                                  if (frames.isEmpty())
+                                          continue;
+                        
+                                  // Take only the first occurence for now. Maybe we should join like for xiph
+                                  TagLib::String frameContents = frames[0]->toString();
+                        
+                                  String value(frameContents.toCString(true), frameContents.size());
+                                  value = sc->convert(value);
+                                  log_debug("Adding frame: %s with value %s\n", desiredFrame.c_str(), value.c_str());
+                                  item->setAuxData(desiredFrame, value);
+                              }
+                  }
+        }
+    
+    void fillAlbumArtID3v2(Ref<CdsItem> item, TagLib::ID3v2::Tag* tag)
+    {
+          if (!tag)
+                  return;
+        
+          TagLib::ID3v2::FrameList list = tag->frameList("APIC");
+          if (list.isEmpty())
+                  return;
+        
+          TagLib::ID3v2::AttachedPictureFrame *art =
+                  static_cast<TagLib::ID3v2::AttachedPictureFrame *>(list.front());
+        
+          if (art->picture().size() < 1)
+                  return;
+        
+          Ref<StringConverter> sc = StringConverter::i2i();
+          String art_mimetype = sc->convert(String(art->mimeType().toCString(true)));
+          // saw that simply "PNG" was used with some mp3's, so mimetype setting
+          // was probably invalid
+          if (!string_ok(art_mimetype) || (art_mimetype.index('/') == -1))
+              {
+                #ifdef HAVE_MAGIC
+                      art_mimetype =  ContentManager::getInstance()->getMimeTypeFromBuffer((void *)art->picture().data(), art->picture().size());
+                      if (!string_ok(art_mimetype))
+                #endif
+                          art_mimetype = _(MIMETYPE_DEFAULT);
+                      }
+          // if we could not determine the mimetype, then there is no
+          // point to add the resource - it's probably garbage
+          if (art_mimetype != _(MIMETYPE_DEFAULT))
+              {
+                      Ref<CdsResource> resource(new CdsResource(CH_ID3));
+                      resource->addAttribute(MetadataHandler::getResAttrName(R_PROTOCOLINFO), renderProtocolInfo(art_mimetype));
+                      resource->addParameter(_(RESOURCE_CONTENT_TYPE), _(ID3_ALBUM_ART));
+                      item->addResource(resource);
+                  }
+        }
+    
+    void fillAuxDataXiph(Ref<CdsItem> item, TagLib::Ogg::XiphComment* comment)
+    {
+          if (!comment || comment->isEmpty())
+                  return;
+          Ref<ConfigManager> cm = ConfigManager::getInstance();
+          Ref<Array<StringBase> > aux = cm->getStringArrayOption(CFG_IMPORT_LIBOPTS_ID3_AUXDATA_TAGS_LIST);
+          if (aux == nil)
+              return;
+          Ref<StringConverter> sc = StringConverter::i2i();
+          const TagLib::Ogg::FieldListMap& fields = comment->fieldListMap();
+          TagLib::Ogg::FieldListMap::ConstIterator fieldsEnd = fields.end();
+          log_debug("Aux size is : %d\n",aux->size());
+          for (int j = 0; j < aux->size(); j++)
+              {
+                      String desiredFrame = aux->get(j);
+                      if (!string_ok(desiredFrame)) 
+                              continue;
+                      TagLib::Ogg::FieldListMap::ConstIterator it = fields.find(desiredFrame.c_str());
+                    if (it != fieldsEnd)
+                        {
+                                // Concatenate all fields into one string with , separator
+                            String value = sc->convert(String(it->second.toString(",").toCString(true)));
+                            log_debug("Adding frame: %s with value %s\n", desiredFrame.c_str(), value.c_str());
+                            item->setAuxData(desiredFrame, value);
+                    }
+            }
+    }
+    
+    void fillAuxData(Ref<CdsItem> item)
+    {
+        Ref<Dictionary> mappings = ConfigManager::getInstance()->getDictionaryOption(CFG_IMPORT_MAPPINGS_MIMETYPE_TO_CONTENTTYPE_LIST);
+        String content_type = mappings->get(item->getMimeType());
+        // Aux Data can't be decoded using the generic TagLib::Tag interface
+        // we instanciate the right type based on content
+        if(content_type == CONTENT_TYPE_MP3)
+            {
+                TagLib::MPEG::File mp(item->getLocation().c_str());
+                if (!mp.isValid())
+                    return;
+                fillAuxDataID3v2(item, mp.ID3v2Tag());
+                fillAlbumArtID3v2(item, mp.ID3v2Tag());
+            }
+        else if(content_type == CONTENT_TYPE_OGG)
+            {
+                TagLib::Ogg::Vorbis::File ogg(item->getLocation().c_str());
+                if (!ogg.isValid())
+                    return;
+                fillAuxDataXiph(item, ogg.tag());
+            }
+        else if(content_type == CONTENT_TYPE_FLAC)
+            {
+                TagLib::FLAC::File flac(item->getLocation().c_str());
+                if (!flac.isValid())
+                    return;
+                // FLAC can contain ID3v2 or XiphComment
+                fillAuxDataID3v2(item, flac.ID3v2Tag());
+                fillAlbumArtID3v2(item, flac.ID3v2Tag());
+                fillAuxDataXiph(item, flac.xiphComment());
+            }
+    }
+}
+
 TagHandler::TagHandler() : MetadataHandler()
 {
 }
@@ -132,9 +308,6 @@
 
 void TagHandler::fillMetadata(Ref<CdsItem> item)
 {
-    Ref<Array<StringBase> > aux;
-    Ref<StringConverter> sc = StringConverter::i2i();
-
     TagLib::FileRef f(item->getLocation().c_str());
 
     if (f.isNull() || (!f.tag()))
@@ -183,93 +356,7 @@
         item->getResource(0)->addAttribute(MetadataHandler::getResAttrName(R_NRAUDIOCHANNELS),
                                            String::from(temp));
     }
-
-    Ref<Dictionary> mappings = ConfigManager::getInstance()->getDictionaryOption(CFG_IMPORT_MAPPINGS_MIMETYPE_TO_CONTENTTYPE_LIST);
-    String content_type = mappings->get(item->getMimeType());
-    // we are done here, album art can only be retrieved from id3v2
-    if (content_type != CONTENT_TYPE_MP3)
-        return;
-
-    // did not yet found a way on how to get to the picture from the file
-    // reference that we already have
-    TagLib::MPEG::File mp(item->getLocation().c_str());
-
-    if (!mp.isValid() || !mp.ID3v2Tag())
-        return;
-
-    //log_debug("Tag contains %i frame(s)\n", mp.ID3v2Tag()->frameListMap().size());
-    Ref<ConfigManager> cm = ConfigManager::getInstance();
-    aux = cm->getStringArrayOption(CFG_IMPORT_LIBOPTS_ID3_AUXDATA_TAGS_LIST);
-    if (aux != nil) 
-    {
-        for (int j = 0; j < aux->size(); j++) 
-        {
-            String desiredFrame = aux->get(j);
-            if (string_ok(desiredFrame)) 
-            {
-                const TagLib::ID3v2::FrameList& allFrames = mp.ID3v2Tag()->frameList();
-                if (!allFrames.isEmpty()) 
-                {
-                    TagLib::ID3v2::FrameList::ConstIterator it = allFrames.begin();
-                    for (; it != allFrames.end(); it++) 
-                    {
-                        TagLib::String frameID((*it)->frameID(), TagLib::String::Latin1);
-                        //log_debug("Found frame: %s\n", frameID.toCString(true));
-
-                        TagLib::ID3v2::TextIdentificationFrame *textFrame =
-                            dynamic_cast<TagLib::ID3v2::TextIdentificationFrame *>(*it);
-
-                        if (textFrame) 
-                        {
-                            //log_debug("We have a TextIdentificationFrame\n");
-
-                            if (frameID == desiredFrame.c_str()) 
-                            {
-                                TagLib::String frameContents = textFrame->toString();
-                                //log_debug("We have a match!!!!: %s\n", frameContents.toCString(true));
-                                String value(frameContents.toCString(true), frameContents.size());
-                                value = sc->convert(value);
-                                log_debug("Adding frame: %s with value %s\n", desiredFrame.c_str(), value.c_str());
-                                item->setAuxData(desiredFrame, value);
-                            }
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    TagLib::ID3v2::FrameList list = mp.ID3v2Tag()->frameList("APIC");
-    if (!list.isEmpty())
-    {
-        TagLib::ID3v2::AttachedPictureFrame *art =
-               static_cast<TagLib::ID3v2::AttachedPictureFrame *>(list.front());
-
-        if (art->picture().size() < 1)
-            return;
-
-        String art_mimetype = sc->convert(art->mimeType().toCString(true));
-        // saw that simply "PNG" was used with some mp3's, so mimetype setting
-        // was probably invalid
-        if (!string_ok(art_mimetype) || (art_mimetype.index('/') == -1))
-        {
-#ifdef HAVE_MAGIC
-            art_mimetype =  ContentManager::getInstance()->getMimeTypeFromBuffer((void *)art->picture().data(), art->picture().size());
-            if (!string_ok(art_mimetype))
-#endif
-            art_mimetype = _(MIMETYPE_DEFAULT);
-        }
-
-        // if we could not determine the mimetype, then there is no
-        // point to add the resource - it's probably garbage
-        if (art_mimetype != _(MIMETYPE_DEFAULT))
-        {
-            Ref<CdsResource> resource(new CdsResource(CH_ID3));
-            resource->addAttribute(MetadataHandler::getResAttrName(R_PROTOCOLINFO), renderProtocolInfo(art_mimetype));
-            resource->addParameter(_(RESOURCE_CONTENT_TYPE), _(ID3_ALBUM_ART));
-            item->addResource(resource);
-        }
-    }
+    fillAuxData(item);
 }
 
 Ref<IOHandler> TagHandler::serveContent(Ref<CdsItem> item, int resNum, off_t *data_size)
diff -Naur before/src/tools.cc after/src/tools.cc
--- before/src/tools.cc	2010-03-25 14:58:11.000000000 +0000
+++ after/src/tools.cc	2013-01-25 20:53:46.000000000 +0000
@@ -637,7 +637,14 @@
 {
     Ref<Array<StringBase> > parts = split_string(protocol, ':');
     if (parts->size() > 2)
-        return parts->get(2);
+    {
+        String extMime = parts->get(2);
+        Ref<Array<StringBase> > subs = split_string(extMime, ';');
+        if (subs->size() > 0)
+            return subs->get(0);
+        else
+            return nil;
+    }
     else
         return nil;
 }
